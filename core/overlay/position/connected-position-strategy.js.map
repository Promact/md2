{"version":3,"file":"connected-position-strategy.js","sourceRoot":"","sources":["../../../../../src/lib/core/overlay/position/connected-position-strategy.ts"],"names":[],"mappings":"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","sourcesContent":["import {PositionStrategy} from './position-strategy';\r\nimport {ElementRef} from '@angular/core';\r\nimport {ViewportRuler} from './viewport-ruler';\r\nimport {\r\n  ConnectionPositionPair,\r\n  OriginConnectionPosition,\r\n  OverlayConnectionPosition,\r\n  ConnectedOverlayPositionChange, ScrollableViewProperties\r\n} from './connected-position';\r\nimport {Subject} from 'rxjs/Subject';\r\nimport {Observable} from 'rxjs/Observable';\r\nimport {Scrollable} from '../scroll/scrollable';\r\n\r\n/**\r\n * Container to hold the bounding positions of a particular element with respect to the viewport,\r\n * where top and bottom are the y-axis coordinates of the bounding rectangle and left and right are\r\n * the x-axis coordinates.\r\n */\r\ntype ElementBoundingPositions = {\r\n  top: number;\r\n  right: number;\r\n  bottom: number;\r\n  left: number;\r\n};\r\n\r\n/**\r\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\r\n * implicit position relative some origin element. The relative position is defined in terms of\r\n * a point on the origin element that is connected to a point on the overlay element. For example,\r\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\r\n * of the overlay.\r\n */\r\nexport class ConnectedPositionStrategy implements PositionStrategy {\r\n  private _dir = 'ltr';\r\n\r\n  /** The offset in pixels for the overlay connection point on the x-axis */\r\n  private _offsetX: number = 0;\r\n\r\n  /** The offset in pixels for the overlay connection point on the y-axis */\r\n  private _offsetY: number = 0;\r\n\r\n  /** The Scrollable containers used to check scrollable view properties on position change. */\r\n  private scrollables: Scrollable[] = [];\r\n\r\n  /** Whether the we're dealing with an RTL context */\r\n  get _isRtl() {\r\n    return this._dir === 'rtl';\r\n  }\r\n\r\n  /** Ordered list of preferred positions, from most to least desirable. */\r\n  _preferredPositions: ConnectionPositionPair[] = [];\r\n\r\n  /** The origin element against which the overlay will be positioned. */\r\n  private _origin: HTMLElement;\r\n\r\n  /** The overlay pane element. */\r\n  private _pane: HTMLElement;\r\n\r\n  /** The last position to have been calculated as the best fit position. */\r\n  private _lastConnectedPosition: ConnectionPositionPair;\r\n\r\n  _onPositionChange:\r\n      Subject<ConnectedOverlayPositionChange> = new Subject<ConnectedOverlayPositionChange>();\r\n\r\n  /** Emits an event when the connection point changes. */\r\n  get onPositionChange(): Observable<ConnectedOverlayPositionChange> {\r\n    return this._onPositionChange.asObservable();\r\n  }\r\n\r\n  constructor(\r\n      private _connectedTo: ElementRef,\r\n      private _originPos: OriginConnectionPosition,\r\n      private _overlayPos: OverlayConnectionPosition,\r\n      private _viewportRuler: ViewportRuler) {\r\n    this._origin = this._connectedTo.nativeElement;\r\n    this.withFallbackPosition(_originPos, _overlayPos);\r\n  }\r\n\r\n  /** Ordered list of preferred positions, from most to least desirable. */\r\n  get positions() {\r\n    return this._preferredPositions;\r\n  }\r\n\r\n  /**\r\n   * To be used to for any cleanup after the element gets destroyed.\r\n   */\r\n  dispose() { }\r\n\r\n  /**\r\n   * Updates the position of the overlay element, using whichever preferred position relative\r\n   * to the origin fits on-screen.\r\n   * @docs-private\r\n   *\r\n   * @param element Element to which to apply the CSS styles.\r\n   * @returns Resolves when the styles have been applied.\r\n   */\r\n  apply(element: HTMLElement): Promise<void> {\r\n    // Cache the overlay pane element in case re-calculating position is necessary\r\n    this._pane = element;\r\n\r\n    // We need the bounding rects for the origin and the overlay to determine how to position\r\n    // the overlay relative to the origin.\r\n    const originRect = this._origin.getBoundingClientRect();\r\n    const overlayRect = element.getBoundingClientRect();\r\n\r\n    // We use the viewport rect to determine whether a position would go off-screen.\r\n    const viewportRect = this._viewportRuler.getViewportRect();\r\n\r\n    // Fallback point if none of the fallbacks fit into the viewport.\r\n    let fallbackPoint: OverlayPoint = null;\r\n    let fallbackPosition: ConnectionPositionPair = null;\r\n\r\n    // We want to place the overlay in the first of the preferred positions such that the\r\n    // overlay fits on-screen.\r\n    for (let pos of this._preferredPositions) {\r\n      // Get the (x, y) point of connection on the origin, and then use that to get the\r\n      // (top, left) coordinate for the overlay at `pos`.\r\n      let originPoint = this._getOriginConnectionPoint(originRect, pos);\r\n      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, pos);\r\n\r\n      // If the overlay in the calculated position fits on-screen, put it there and we're done.\r\n      if (overlayPoint.fitsInViewport) {\r\n        this._setElementPosition(element, overlayRect, overlayPoint, pos);\r\n\r\n        // Save the last connected position in case the position needs to be re-calculated.\r\n        this._lastConnectedPosition = pos;\r\n\r\n        // Notify that the position has been changed along with its change properties.\r\n        const scrollableViewProperties = this.getScrollableViewProperties(element);\r\n        const positionChange = new ConnectedOverlayPositionChange(pos, scrollableViewProperties);\r\n        this._onPositionChange.next(positionChange);\r\n\r\n        return Promise.resolve(null);\r\n      } else if (!fallbackPoint || fallbackPoint.visibleArea < overlayPoint.visibleArea) {\r\n        fallbackPoint = overlayPoint;\r\n        fallbackPosition = pos;\r\n      }\r\n    }\r\n\r\n    // If none of the preferred positions were in the viewport, take the one\r\n    // with the largest visible area.\r\n    this._setElementPosition(element, overlayRect, fallbackPoint, fallbackPosition);\r\n\r\n    return Promise.resolve(null);\r\n  }\r\n\r\n  /**\r\n   * This re-aligns the overlay element with the trigger in its last calculated position,\r\n   * even if a position higher in the \"preferred positions\" list would now fit. This\r\n   * allows one to re-align the panel without changing the orientation of the panel.\r\n   */\r\n  recalculateLastPosition(): void {\r\n    const originRect = this._origin.getBoundingClientRect();\r\n    const overlayRect = this._pane.getBoundingClientRect();\r\n    const viewportRect = this._viewportRuler.getViewportRect();\r\n    const lastPosition = this._lastConnectedPosition || this._preferredPositions[0];\r\n\r\n    let originPoint = this._getOriginConnectionPoint(originRect, lastPosition);\r\n    let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, viewportRect, lastPosition);\r\n    this._setElementPosition(this._pane, overlayRect, overlayPoint, lastPosition);\r\n  }\r\n\r\n  /**\r\n   * Sets the list of Scrollable containers that host the origin element so that\r\n   * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\r\n   * Scrollable must be an ancestor element of the strategy's origin element.\r\n   */\r\n  withScrollableContainers(scrollables: Scrollable[]) {\r\n    this.scrollables = scrollables;\r\n  }\r\n\r\n  /**\r\n   * Adds a new preferred fallback position.\r\n   * @param originPos\r\n   * @param overlayPos\r\n   */\r\n  withFallbackPosition(\r\n      originPos: OriginConnectionPosition,\r\n      overlayPos: OverlayConnectionPosition): this {\r\n    this._preferredPositions.push(new ConnectionPositionPair(originPos, overlayPos));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets the layout direction so the overlay's position can be adjusted to match.\r\n   * @param dir New layout direction.\r\n   */\r\n  withDirection(dir: 'ltr' | 'rtl'): this {\r\n    this._dir = dir;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets an offset for the overlay's connection point on the x-axis\r\n   * @param offset New offset in the X axis.\r\n   */\r\n  withOffsetX(offset: number): this {\r\n    this._offsetX = offset;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Sets an offset for the overlay's connection point on the y-axis\r\n   * @param  offset New offset in the Y axis.\r\n   */\r\n  withOffsetY(offset: number): this {\r\n    this._offsetY = offset;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Gets the horizontal (x) \"start\" dimension based on whether the overlay is in an RTL context.\r\n   * @param rect\r\n   */\r\n  private _getStartX(rect: ClientRect): number {\r\n    return this._isRtl ? rect.right : rect.left;\r\n  }\r\n\r\n  /**\r\n   * Gets the horizontal (x) \"end\" dimension based on whether the overlay is in an RTL context.\r\n   * @param rect\r\n   */\r\n  private _getEndX(rect: ClientRect): number {\r\n    return this._isRtl ? rect.left : rect.right;\r\n  }\r\n\r\n\r\n  /**\r\n   * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\r\n   * @param originRect\r\n   * @param pos\r\n   */\r\n  private _getOriginConnectionPoint(originRect: ClientRect, pos: ConnectionPositionPair): Point {\r\n    const originStartX = this._getStartX(originRect);\r\n    const originEndX = this._getEndX(originRect);\r\n\r\n    let x: number;\r\n    if (pos.originX == 'center') {\r\n      x = originStartX + (originRect.width / 2);\r\n    } else {\r\n      x = pos.originX == 'start' ? originStartX : originEndX;\r\n    }\r\n\r\n    let y: number;\r\n    if (pos.originY == 'center') {\r\n      y = originRect.top + (originRect.height / 2);\r\n    } else {\r\n      y = pos.originY == 'top' ? originRect.top : originRect.bottom;\r\n    }\r\n\r\n    return {x, y};\r\n  }\r\n\r\n\r\n  /**\r\n   * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\r\n   * origin point to which the overlay should be connected, as well as how much of the element\r\n   * would be inside the viewport at that position.\r\n   */\r\n  private _getOverlayPoint(\r\n      originPoint: Point,\r\n      overlayRect: ClientRect,\r\n      viewportRect: ClientRect,\r\n      pos: ConnectionPositionPair): OverlayPoint {\r\n    // Calculate the (overlayStartX, overlayStartY), the start of the potential overlay position\r\n    // relative to the origin point.\r\n    let overlayStartX: number;\r\n    if (pos.overlayX == 'center') {\r\n      overlayStartX = -overlayRect.width / 2;\r\n    } else if (pos.overlayX === 'start') {\r\n      overlayStartX = this._isRtl ? -overlayRect.width : 0;\r\n    } else {\r\n      overlayStartX = this._isRtl ? 0 : -overlayRect.width;\r\n    }\r\n\r\n    let overlayStartY: number;\r\n    if (pos.overlayY == 'center') {\r\n      overlayStartY = -overlayRect.height / 2;\r\n    } else {\r\n      overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\r\n    }\r\n\r\n    // The (x, y) coordinates of the overlay.\r\n    let x = originPoint.x + overlayStartX + this._offsetX;\r\n    let y = originPoint.y + overlayStartY + this._offsetY;\r\n\r\n    // How much the overlay would overflow at this position, on each side.\r\n    let leftOverflow = 0 - x;\r\n    let rightOverflow = (x + overlayRect.width) - viewportRect.width;\r\n    let topOverflow = 0 - y;\r\n    let bottomOverflow = (y + overlayRect.height) - viewportRect.height;\r\n\r\n    // Visible parts of the element on each axis.\r\n    let visibleWidth = this._subtractOverflows(overlayRect.width, leftOverflow, rightOverflow);\r\n    let visibleHeight = this._subtractOverflows(overlayRect.height, topOverflow, bottomOverflow);\r\n\r\n    // The area of the element that's within the viewport.\r\n    let visibleArea = visibleWidth * visibleHeight;\r\n    let fitsInViewport = (overlayRect.width * overlayRect.height) === visibleArea;\r\n\r\n    return {x, y, fitsInViewport, visibleArea};\r\n  }\r\n\r\n  /**\r\n   * Gets the view properties of the trigger and overlay, including whether they are clipped\r\n   * or completely outside the view of any of the strategy's scrollables.\r\n   */\r\n  private getScrollableViewProperties(overlay: HTMLElement): ScrollableViewProperties {\r\n    const originBounds = this._getElementBounds(this._origin);\r\n    const overlayBounds = this._getElementBounds(overlay);\r\n    const scrollContainerBounds = this.scrollables.map((scrollable: Scrollable) => {\r\n      return this._getElementBounds(scrollable.getElementRef().nativeElement);\r\n    });\r\n\r\n    return {\r\n      isOriginClipped: this.isElementClipped(originBounds, scrollContainerBounds),\r\n      isOriginOutsideView: this.isElementOutsideView(originBounds, scrollContainerBounds),\r\n      isOverlayClipped: this.isElementClipped(overlayBounds, scrollContainerBounds),\r\n      isOverlayOutsideView: this.isElementOutsideView(overlayBounds, scrollContainerBounds),\r\n    };\r\n  }\r\n\r\n  /** Whether the element is completely out of the view of any of the containers. */\r\n  private isElementOutsideView(\r\n      elementBounds: ElementBoundingPositions,\r\n      containersBounds: ElementBoundingPositions[]): boolean {\r\n    return containersBounds.some((containerBounds: ElementBoundingPositions) => {\r\n      const outsideAbove = elementBounds.bottom < containerBounds.top;\r\n      const outsideBelow = elementBounds.top > containerBounds.bottom;\r\n      const outsideLeft = elementBounds.right < containerBounds.left;\r\n      const outsideRight = elementBounds.left > containerBounds.right;\r\n\r\n      return outsideAbove || outsideBelow || outsideLeft || outsideRight;\r\n    });\r\n  }\r\n\r\n  /** Whether the element is clipped by any of the containers. */\r\n  private isElementClipped(\r\n      elementBounds: ElementBoundingPositions,\r\n      containersBounds: ElementBoundingPositions[]): boolean {\r\n    return containersBounds.some((containerBounds: ElementBoundingPositions) => {\r\n      const clippedAbove = elementBounds.top < containerBounds.top;\r\n      const clippedBelow = elementBounds.bottom > containerBounds.bottom;\r\n      const clippedLeft = elementBounds.left < containerBounds.left;\r\n      const clippedRight = elementBounds.right > containerBounds.right;\r\n\r\n      return clippedAbove || clippedBelow || clippedLeft || clippedRight;\r\n    });\r\n  }\r\n\r\n  /** Physically positions the overlay element to the given coordinate. */\r\n  private _setElementPosition(\r\n      element: HTMLElement,\r\n      overlayRect: ClientRect,\r\n      overlayPoint: Point,\r\n      pos: ConnectionPositionPair) {\r\n\r\n    // We want to set either `top` or `bottom` based on whether the overlay wants to appear above\r\n    // or below the origin and the direction in which the element will expand.\r\n    let verticalStyleProperty:any = pos.overlayY === 'bottom' ? 'bottom' : 'top';\r\n\r\n    // When using `bottom`, we adjust the y position such that it is the distance\r\n    // from the bottom of the viewport rather than the top.\r\n    let y = verticalStyleProperty === 'top' ?\r\n        overlayPoint.y :\r\n        document.documentElement.clientHeight - (overlayPoint.y + overlayRect.height);\r\n\r\n    // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\r\n    // or \"after\" the origin, which determines the direction in which the element will expand.\r\n    // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\r\n    // page is in RTL or LTR.\r\n    let horizontalStyleProperty: any;\r\n    if (this._dir === 'rtl') {\r\n      horizontalStyleProperty = pos.overlayX === 'end' ? 'left' : 'right';\r\n    } else {\r\n      horizontalStyleProperty = pos.overlayX === 'end' ? 'right' : 'left';\r\n    }\r\n\r\n    // When we're setting `right`, we adjust the x position such that it is the distance\r\n    // from the right edge of the viewport rather than the left edge.\r\n    let x = horizontalStyleProperty === 'left' ?\r\n      overlayPoint.x :\r\n      document.documentElement.clientWidth - (overlayPoint.x + overlayRect.width);\r\n\r\n\r\n    // Reset any existing styles. This is necessary in case the preferred position has\r\n    // changed since the last `apply`.\r\n    ['top', 'bottom', 'left', 'right'].forEach((p: any) => element.style[p] = null);\r\n\r\n    element.style[verticalStyleProperty] = `${y}px`;\r\n    element.style[horizontalStyleProperty] = `${x}px`;\r\n  }\r\n\r\n  /** Returns the bounding positions of the provided element with respect to the viewport. */\r\n  private _getElementBounds(element: HTMLElement): ElementBoundingPositions {\r\n    const boundingClientRect = element.getBoundingClientRect();\r\n    return {\r\n      top: boundingClientRect.top,\r\n      right: boundingClientRect.left + boundingClientRect.width,\r\n      bottom: boundingClientRect.top + boundingClientRect.height,\r\n      left: boundingClientRect.left\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Subtracts the amount that an element is overflowing on an axis from it's length.\r\n   */\r\n  private _subtractOverflows(length: number, ...overflows: number[]): number {\r\n    return overflows.reduce((currentValue: number, currentOverflow: number) => {\r\n      return currentValue - Math.max(currentOverflow, 0);\r\n    }, length);\r\n  }\r\n}\r\n\r\n/** A simple (x, y) coordinate. */\r\ninterface Point {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\n/**\r\n * Expands the simple (x, y) coordinate by adding info about whether the\r\n * element would fit inside the viewport at that position, as well as\r\n * how much of the element would be visible.\r\n */\r\ninterface OverlayPoint extends Point {\r\n  visibleArea?: number;\r\n  fitsInViewport?: boolean;\r\n}\r\n"]}