{"version":3,"file":"scroll-dispatcher.js","sourceRoot":"","sources":["../../../../../src/lib/core/overlay/scroll/scroll-dispatcher.ts"],"names":[],"mappings":"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","sourcesContent":["import {Injectable, ElementRef, Optional, SkipSelf} from '@angular/core';\nimport {Scrollable} from './scrollable';\nimport {Subject} from 'rxjs/Subject';\nimport {Observable} from 'rxjs/Observable';\nimport {Subscription} from 'rxjs/Subscription';\nimport 'rxjs/add/observable/fromEvent';\nimport 'rxjs/add/operator/auditTime';\n\n\n/** Time in ms to throttle the scrolling events by default. */\nexport const DEFAULT_SCROLL_TIME = 20;\n\n/**\n * Service contained all registered Scrollable references and emits an event when any one of the\n * Scrollable references emit a scrolled event.\n */\n@Injectable()\nexport class ScrollDispatcher {\n  /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n  _scrolled: Subject<void> = new Subject<void>();\n\n  /**\n   * Map of all the scrollable references that are registered with the service and their\n   * scroll event subscriptions.\n   */\n  scrollableReferences: Map<Scrollable, Subscription> = new Map();\n\n  constructor() {\n    // By default, notify a scroll event when the document is scrolled or the window is resized.\n    Observable.fromEvent(window.document, 'scroll').subscribe(() => this._notify());\n    Observable.fromEvent(window, 'resize').subscribe(() => this._notify());\n  }\n\n  /**\n   * Registers a Scrollable with the service and listens for its scrolled events. When the\n   * scrollable is scrolled, the service emits the event in its scrolled observable.\n   *\n   * @param scrollable Scrollable instance to be registered.\n   */\n  register(scrollable: Scrollable): void {\n    const scrollSubscription = scrollable.elementScrolled().subscribe(() => this._notify());\n    this.scrollableReferences.set(scrollable, scrollSubscription);\n  }\n\n  /**\n   * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n   *\n   * @param scrollable Scrollable instance to be deregistered.\n   */\n  deregister(scrollable: Scrollable): void {\n    this.scrollableReferences.get(scrollable).unsubscribe();\n    this.scrollableReferences.delete(scrollable);\n  }\n\n  /**\n   * Returns an observable that emits an event whenever any of the registered Scrollable\n   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n   * to override the default \"throttle\" time.\n   */\n  scrolled(auditTimeInMs: number = DEFAULT_SCROLL_TIME): Observable<void> {\n    // In the case of a 0ms delay, return the observable without auditTime since it does add\n    // a perceptible delay in processing overhead.\n    if (auditTimeInMs == 0) {\n      return this._scrolled.asObservable();\n    }\n\n    return this._scrolled.asObservable().auditTime(auditTimeInMs);\n  }\n\n  /** Returns all registered Scrollables that contain the provided element. */\n  getScrollContainers(elementRef: ElementRef): Scrollable[] {\n    const scrollingContainers: Scrollable[] = [];\n\n    this.scrollableReferences.forEach((subscription: Subscription, scrollable: Scrollable) => {\n      if (this.scrollableContainsElement(scrollable, elementRef)) {\n        scrollingContainers.push(scrollable);\n      }\n    });\n\n    return scrollingContainers;\n  }\n\n  /** Returns true if the element is contained within the provided Scrollable. */\n  scrollableContainsElement(scrollable: Scrollable, elementRef: ElementRef): boolean {\n    let element = elementRef.nativeElement;\n    let scrollableElement = scrollable.getElementRef().nativeElement;\n\n    // Traverse through the element parents until we reach null, checking if any of the elements\n    // are the scrollable's element.\n    do {\n      if (element == scrollableElement) { return true; }\n    } while (element = element.parentElement);\n  }\n\n  /** Sends a notification that a scroll event has been fired. */\n  _notify() {\n    this._scrolled.next();\n  }\n}\n\nexport function SCROLL_DISPATCHER_PROVIDER_FACTORY(parentDispatcher: ScrollDispatcher) {\n  return parentDispatcher || new ScrollDispatcher();\n}\n\nexport const SCROLL_DISPATCHER_PROVIDER = {\n  // If there is already a ScrollDispatcher available, use that. Otherwise, provide a new one.\n  provide: ScrollDispatcher,\n  deps: [[new Optional(), new SkipSelf(), ScrollDispatcher]],\n  useFactory: SCROLL_DISPATCHER_PROVIDER_FACTORY\n};\n"]}